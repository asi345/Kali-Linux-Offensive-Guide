#NETWORK

##MAC address
- Media Access Control
- unique for network device (wired or Ethernet card etc.)
- always the same for a device
- changing it increases anonymity, bypasses filters impersonates other devices
- of course, you can not change the physical address, you can just change the address in memory
- every packet has source and destination MAC address
- because all packets sent in the air, it is possible to capture packets even if we do not have the destination MAC

##ifconfig
- shows all devices that can connect to the network
- only connected devices have IP address

###ifconfig <network-interface> down/up
- disables/enables the network device

###ifconfig <network-interface> <attribute> <value>
- changes the given attribute of the network to value
- for MAC address, attribute = *hw ether* and set first two characters as *00*

##iwconfig
- shows all wireless interfaces
- change the *Mode* of the interface to *Monitor* to see all packets in the area of this wireless

###iwconfig <wireless-interface> <attribute> <value>
- for monitor mode, attribute = *mode* and value = *monitor*

##airmon-ng check kill
- kills any process that can interfere with wireless interface
- cuts the connection to internet

##airodump-ng <wireless-interface>
- in monitor mode, shows info about wireless networks around
- only shows 2.4 Ghz networks
- BSSID : MAC address
- PWR : signal power (higher is better)
- Beacons : broadcats the network's existence
- Data : number of data packets
- /s : number of data packets in last 10 seconds
- CH : the channel netowrk works on
- MB : max speed supported by the network
- ENC : encryption used by the network (OPN for open, no password)
- CIPHER : cipher used in the network
- AUTH : authentication used on the network
- ESSID : name of the network

###--band
- specifies bands for the networks searched
- *a* : 5 Ghz networks
- *abg* : both 2.4 and 5 Ghz networks

###--bssid
- sniffs data from only specified network by MAC address

###--channel
- give also channel number while sniffing data from specific network

- by giving these 2 as argument, clients connected to the wireless network can be seen
- Rate : speed
- Frames : captured packets
- Probe : if the device is still probing for network

###--write
- writes the sniffed data to the file
- appends *-01-* automatically
- use *.cap* in general
- the file contains all the data sent to and from the target network but they are encrypted by the router encryption

##WIFI Bands
- the frequency range that network can use to broadcast the signal
- most common : 2.4 Ghz and 5 Ghz

##wireshark
- program to open *.cap* files
- enlists all the data packets sniffed
- *Source* section shows the manufacturer of the device with the MAC address

##aireplay-ng --deauth <number> -a <router-MAC> -c <device-MAC> <wireless-interface>
- deauthentication attack
- disconnects the client with MAC address *device-MAC* from the network with MAC address *router-MAC*
- sends deauthenticaton packets to the both router and device
- do not forget to give the wireless adapter name
- wireless adapter should be in monitor mode
- use this while running *airodump-ng* to get better results
- <number> specifies how many deauth packets will be send so it will determine the disconnection time

##WEP Encryption
- stands for Wired Equivalent Privacy
- older from orther router encryptions and not safe
- uses the algorithm RC4
- the problem is not the algorithm, it is the implementation
- a keystream for the packet is created by adding unique 24-bit initialization vector and the network key
- the packet contains the hash and the vector, the key is already found in the router and device
- then the reciever can decrypt the data using the keystream
- 24-bits is not much so for a busy network, the same vector can appear in some different transactions
- so this means the keystream for them is the same
- from this info, it is possible to crack the key
- just capture a large number of packets (4Head) with *airodump-ng*
- analyze the captured vectors andcrack the key with *aircrack-ng*
- attack described above works only if the network is busy
- if the network is busy, we need to inject data packets to it to increase the nof data packets
- to do that we need to associate with the network (tell the network that we need to communicate with it, the network ignores other requests;
only communicates with connected clients)
- to associate, first use *airdump-ng* with *bssid, channel, write, interface* and keep it open or close
- then use *aireplay-ng* as given below
- then force the access point(AP) to generate new packets with new IVs(24-bit vectors) using *aireplay-ng*, ARP replay attack
- first wait for an *ARP* packet and capture it
- then retransmit it and this causes AP to generate a new packet with new IV
- repeat this until we have enough packets
- lastly, crack the key like it is a busy network
- while cracking, *airodump-ng* and *aireplay-ng* can still run

##aircrack-ng <cap-file>
- cracks the WEP encrypted router key
- first write the captured data packets to a file by using *airodump-ng*
- then give the *.cap* file as an argument to this command
- the result given in ASCI section is the key
- if there is no ASCI section, take the hex number with semicolons; it is the hex of the key
- remove semicolons and use the rest number as key

##aireplay-ng --fakeauth 0 -a <router-MAC> -h <adapter-MAC> <wireless-interface>
- fake authentication attack, associates with the network
- to find adapter MAC, use *ifconfig* and the MAC is the first 12 characters of the *unspec* field
- replace *-* with *:*
- adapter should be in monitor mode
- when activated, the wireless adapter should appear in *airodump-ng* because it is associated and can communicate with the network
- *AUTH* field also can be *OPN*

##aireplay-ng --arpreplay -b <router-MAC> -h <adapter-MAC> <wireless-interface>
- ARP replay attack (forcing to generate packets)
- similar procedures with the fake authentication attack
- enough to get around 45k packets

##WPA and WPA2 Encryption
- WPA uses *TKIP* and WPA2 uses *CCMP* encryption algorithms
- both of them are cracked in the same way
- *WPS* allows devices to connect the router without the key (for printer etc.)
- press WPS button on both device and the router to do it
- authentication is done with a 8-digit pin
- the number of possible passwords is therefore less than a secure a key
- so we exploit the feature, not the encryption
- to do this, WPS should be enabled on the network and it should be misconfigured which means it should use the normal pin
authentication; not push button authentication(PBC)
- in most new routers, WPS is disabled and PBC is enabled :( Sadge but check whether WPS is enabled in any case using *wash*
- after finding the network to connect, use *Reaver* like below to first to find the right pin for WPS by trying all pins
- this pin is used to compute the actual key, Reaver also shows it when terminates
- at the same time with reaver, associate with it like in WEP but use *--fakeauth 30* which means associate every 30 seconds

- if the WPS is disabled, we need to crack the actual encryption of WPA and WPA2
- the data packets contain no useful information, we need to capture handshake packects which are sent between the router and the
client connects to it
- to capture the packets first use in monitor mode *airodump-ng* just like in WEP on a specific network and write the packets into a file
- now we need to wait a client to connect to the network so that we can capture a handshake packet
- instead of just waiting, just do a deauthentication attack to a connected client for a short time and then it will connect automatically
again
- when the client connects again, the handshake appears at the top of the *airodump-ng* then we can quit
- handshake packets can not be used to find the key, it can be used to check if a password is valid or not
- so we need to create a *wordlist* file with passwords in it and we try them one by one
- we can download wordlists from internet but to generate one, use *crunch* (explained below)
- then first unpack the handshake packets to get useful information
- *MIC(Message Integrity Code)* checks whether the password is correct or not
- *aircrack-ng* separates the MIC in the handshake packet and takes a password from the wordlist
- it then combines other informations in the packet to generate a MIC with the password
- if the generated MIC is the same as the original, then the true password is found
- use *aircrack-ng* like below
- to speed up the process, run the attack on GPU instead of CPU if possible or pipe the result of *crunch* to *aircrack-ng*

##wash --interface <wireless-interface>
- lists all networks with WPS enabled
- adapter should be in monitor mode
- keeps running until you cancel it
- *Vendor* : hardware used in this network
- *Lck* : if WPS is locked or not (if locked, PepeHands)
- *WPS* : version
- *dBm* : signal strength
- *Ch* : channel

##reaver --bssid <router-MAC> --channel <ch> --interface <wireless-interface> -vvv --no-associate
- WPS pin attack
- download the older version if it does not work
- *-vvv* shows more info
- *--no-associate* tells reaver to not associate because we will do it manually, it has higher chance to fail when done automatically
- shows the cracked pin and network key when the process is done

##crunch <min> <max> <characters> -t <pattern> -o <file>
- wordlist generation
- min and max specifies min and max number of characters in the password
- characters specifies which characters are used in the password
- pattern specifies a clue to be used in the password (in example, the password starts with a, like regex)
- use *@* to use wildcard character in the pattern, but it represents only one character like *.*
- the generated passwords are written in the file
- there are much more options, use man to see them (-p is important)

##aircrack-ng <cap-file> -w <wordlist-file>
- wordlist attack
- use the *.cap* file generated from *airodump-ng*
- tests all passwords in the wordlist file one by one to find the correct one
- the program shows you the password if the attack is successful
- because the speed of this attack really depends on the processor and the wordlist size, search the internet sites where they have
huge wordlists and super computers so that by uploading the handshake packet file, it finds the true password faster

##IP Address
- stands for *Internet Protocol*
- the IP address of the network device can be found by using *ifconfig* like below
- the IP address of the router is the first address in the subnet
- if the device has IP : 192.168.0.25, the router should have 192.168.0.1

##ifconfig <wireless-interface>
- IP address is the field *inet addr*

##Information Gathering in Network
- use *NetDiscover* to map the network we connected to
- you can only gather info from the devices that connected to the same network with you
- use *NMap* to get much much more information, it is a huge tool
- it can show the running programs on a computer or the operating system
- *Zenmap* is a program to utilize Nmap terminal command in a graphical interface

##netdiscover -r <ip-range>
- gathering information about the network
- ip range should start with the router ip (X.X.X.1)
- the range from 1 to 254 can be specified by X.X.X.1/24
- this way the whole subnet ip is specified
- if done via the wireless adapter, the wired connection to the virtual machine must be disabled
- devices > network > connect network adapter uncheck

##Zenmap
- call by typing zenmap in the terminal
- into the target box, give an IP or a range of IPS
- *Ping scan* : very fast, just shows which IP addresses are used in the network by the devices and the manufacturer with MAC addresses
- *Quick scan* : also shows the open ports in the devices
- *Quick scan plus* : also shows the os, device type, and the program running
- Services section shows which devices use which service
- ports are so important because we decide how to hack the device by looking at their open ports

##MITM Attacks
- Man in the Middle Attacks
- they are the attacks that can be launched when we intercept the communication between devices
- *ARP Spoofing* : the hacker gets himself in the connection path of two devices, so the packets are sent to hacker and from there,
to the destination
- by spoofing, the hacker can see everything flowing including passwords and redirect or drop the packets
- this is possible because ARP is not secure
- ARP stands for *Address Resolution Protocol* and maps IP addresses to MAC addresses
- the communication inside a network is done by using MAC address
- a client wanting to connect to another client in the same network first does a ARP Request saying "Who has this IP?" (target IP)
- device having the target IP will send an ARP Respons telling "I have this IP and my MAC address is attached"
- so the source now has the target MAC to communicate with the device
- each computer has ARP table which holds corresponding MAC addresses to the IP addresses for the devices in the same network, it can
be seen by using *arp* like below
- this linking can be exploited by changing the MAC addresses
- when a target computer is selected, we tell the router that we have the IP address of the target computer so it associates our MAC with
that IP
- we also tell the target computer that we have the IP of the router so it updates its ARP table with IP of the router having our MAC
- this way, we become the man in the middle because all the data sent between the router and the target first comes to us and we forward them,
this attack is called ARP spoofing
- ARP is not secure because clients can get responses even if they did not sent requests
- the attack explained above sends responses to both router and target without them asking anything but they accept it anyway
- also the ARP Protocol does not verify these responses and does not check who sent it, it trusts the given data

- *arpspoof* is a tool to make us man in the middle, so we intercept the data flow and it can work on many os
- by default, the computer does not allow data packets to go through, so the request are rejected when the target wants to access
something
- to overcome this, we need to enable port forwarding, use the *echo* command below
- *bettercap* is a better tool for ARP spoofing and also sniffing data(username, password, etc.), bypassing HTTPS, DNS spoofing,
injecting code to loaded pages and more
- in websites using HTTP, the datas are sent as plain text so if we become the man in the middle; we can directly see this text and read it
- that is why HTTP is not secure
- in HTTPS, this problem is solved by adding an extra encryption layer by using TLS(Transport Layer Security) or SSL(Secure Sockets Layer)
- so we still become man in the middle but the datas we read are encrypted so we can not understand the content
- to bypass HTTPS, when we take requests from the target, we downgrade it to HTTP so when the router send response we can read it easily
using *bettercap* in the same way
- to do that, we need to change the folder *hstshijack* with an updated one, you can find it in the course resources and the command is given
in the section *net.sniff*
- some very famous websites use *HSTS*, which is more secure than HTTPS and can not be downgraded
- modern websites are hard-coded to load only a list of HSTS websites over HTTPS
- when the target computer is in a website with HSTS, that computer sends and accepts only HTTPS links so we can not get the request and responses
in HTTP from it anymore
- to overcome this, we should trick the target computer to think it is loading a different website
- see *hstshijack* module below to get to know some options
- HSTS can not be bypassed if the target HSTS website is loaded from another HSTS website(Google), so the solution is partial

##HTTP, HTTPS and HSTS
- stands for *Hypertext Transfer Protocol*, *Hypertext Transfer Protocol Secure* and *HTTP Strict Transport Security*
- in HSTS, for example, change *facebook.com* to *facebook.corn* xd or *twitter.com* to *twiter.com* xd
- in order this HSTS attack to work, the target website should not be loaded from a HSTS websites
- for example, the target should not load facebook from google, so bypassing HSTS is a partial solution

##arp -a
- shows the ARP table recorded in the computer

##arpspoof -i <network-interface> -t <target-IP> <router-IP>
##arpspoof -i <network-interface> -t <router-IP> <target-IP>
- allows you to intercept the connection between target and the router
- all packets between them will flow through us
- first one tells the target that we are the router
- second one tells the router that we are the target
- so the target changes the MAC address of the router to our MAC address
- similar for router

##echo 1 > /proc/sys/net/ipv4/ip_forward
- enables port forwarding

##bettercap -iface <network-interface> (optional) -caplet <.cap>
- starts the bettercap command prompt
- type *help* to see the modules
- type *help <module-name>* to get information about the module
- auto completion works with tab
- when we want to give bettercap a headstart by executing some commands, type all of the commands in a *.cap* and give it as an argument
- for example, when sniffing data by ARP spoofing, open a .cap file and type these:
	1. net.probe on
	2. set arp.spoof.fullduplex true
	3. set arp.spoof.targets <target-IP>
	4. arp.spoof on
	5. set net.sniff.local true (only if we want to capture HTTPS)
	6. net.sniff on
- to run a caplet in the bettercap terminal, directly type its name
- wildcards in the terminal can be used in bettercap, especially *

###<module-name> on
- starts the specific module
- only after setting all the parameters of the module, run this to start the attack

###set <module.parameter> <value>
- sets the attribute of the module to the value
- for example, *set arp.spoof.fullduplex true*

###net.probe on
- shows the clients connected to same network
- it automatically starts the module *net.recon* because this module sends probe request to all IPs and if they respond they all are taken
to a list by net.recon

###net.show
- when net.probe is already on, the discovered clients are shown in a table giving basic information about them like *airodump-ng*
- *gateway* speicifes the router
- *<network-interface>* specifies this computer

###arp.spoof
- arp spoofing with bettercap
- *arp.ban on* : cuts the connection of the target
- make sure *net.probe* and *net.recon* is running before starting this module
- after turning on this module, in the target machine, the MAC address of both the router and our computer should be the same and be equal
to the MAC address of our computer (check with ifconfig)

####fullduplex
- both the target and the router are attacked and we become man in the middle
- default will only attack the target, so set the router also by using *arp.spoof.fullduplex true*

####targets
- default is entire subnet
- give the IP address of the target

###net.sniff
- sniffs datas flowing through our computer when we are man in the middle, captures them and we can analyze it
- can be run without setting any parameter if HTTPS websites are not cared
- maybe can not capture datas in websites using *https*
- when browsing on the internet in the target computer, it shows urls with any images or files also loaded from the website
- also when logged in on a website in the target computer, the username and the password is shown directly
- by default, it will only capture datas in HTTP because those datas are sent as plain text so they are not secure
- to also capture datas in HTTPS, run the caplet *hstshijack/hstshijack* after turning on this module

###caplets.show
- shows all the *.cap* files in the system
- we should be able to locate *hstshijack* caplet here to downgrade HTTPS to HTTP

###hstshijack
- downgrades HTTPS to HTTP and transforms website links with HSTS to similar websites
- *facebook.com* -> *facebook.corn*

####targets
- target websites using HSTS

####replacements
- replace the targets with these ones
- write the replacements in the order of the targets

##DNS Spoofing
- it is a server that converts domain names(google.com) to the IP of the server hosting this website
- notice that there is no *www* at the start of the domain name
- when an url given to a web browser, the request goes to a DNS server and it responds with the IP of that url
- then the browser will load the website from this IP
- when we are man in the middle, target sends request to a website with the domain name; but as respond from DNS server, we can return any IP
we want so we can load any website, inject evil, hijack updates etc.
- to start the DNS spoofing, first start the bettercap as if we were bypassing HTTPS; use the arpspoof.cap file
- then downgrade HTTPS to HTTP for to be sure it will work
- then use the *dns.spoof* module below
- the attack will work in 1-2 minute
- this attack will not work on websites using HSTS

###dns.spoof
- replies the DNS messages with spoofed responses
- set *all* to true
- set *address* and *domains* and then turn on the module

####address
- IP address that we return to the target computer
- the default is the IP address of our current running network interface
- so do not modify it if you want to locate to our IP address

####all
- makes the module reply to every DNS request sent

####domains
- the domain names of the websites(facebook.com) to be redirected to the IP we give
- seperate websites with commas
- give the target url but also the subdomain containing it (\*.facebook.com)

##Website from our web server
- Kali comes with a built in web server
- type *service apache2 start* to run it
- now it acts as a normal website which can be reached when the IP address of our computer is given to web browser as url
- the files uploaded to this website can be found in */var/www/html*
- *index.html* is the loaded by default as gui

##Injecting Javascript code
- because the data flows through our computer when we are man in the middle, if th router has responded with a webpage with HTML and Javascript
code, we can change it or add to it our own code
- HTML code only organizes buttons, tables or similar things in user interface
- but Javascript is a powerful programming language allowing us to do much and this code is executed by the target browser
- this can be used to replace links and images, insert HTML elements, hook target browser to exploitation frameworks etc.
- to inject the code, first prepare a *.js* file for the code to inject
- then go to the *hstshijack.cap* in */usr/share/bettercap/caplets/hstshijack/hstshijack.cap*
- the line with *set hstshijack.payloads* command specifies what js code to inject when loading specified domains
- *\*:* means inject the specified code to all load webpages, then give the full path of the js code we want to insert
- separate injections by comma
- preparation is now complete, just do the same procedure now with the data sniffing and hstshajicak folder
- launch *bettercap* with the interface and the *arpspoof.cap* file and then run *hstshijack/hstshijack* in it

##Wireshark
- network protocol analyzer
- shows what is happening and which user is doing what in the network
- loads all the flowing data packets and allows to filter them
- it also allows to search the packets
- it is not originally a hacking tool it is just showing what is flowing on your network interface, it does not show what is happening in other
devices
- you can open a already prepared file with captured data information from the menu
- in the main screen, you see the wireless inferfaces in the computer
- the lines are graphing the data traffic in them
- when we become the man in the middle, we can also see the data traffic in the target's computer
- go to the *capture options* on the top left to select the interface we want the analyze the data packets on and start the program there
